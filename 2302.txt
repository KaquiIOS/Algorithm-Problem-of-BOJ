극장 좌석 성공 
시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
2 초	128 MB	3516	1542	1305	43.675%
문제
어떤 극장의 좌석은 한 줄로 되어 있으며 왼쪽부터 차례대로 1번부터 N번까지 번호가 매겨져 있다. 
공연을 보러 온 사람들은 자기의 입장권에 표시되어 있는 좌석에 앉아야 한다. 예를 들어서, 입장권에 5번이 써 있으면 5번 좌석에 앉아야 한다. 단, 자기의 바로 왼쪽 좌석 또는 바로 오른쪽 좌석으로는 자리를 옮길 수 있다. 예를 들어서, 7번 입장권을 가진 사람은 7번 좌석은 물론이고, 6번 좌석이나 8번 좌석에도 앉을 수 있다. 그러나 5번 좌석이나 9번 좌석에는 앉을 수 없다.

그런데 이 극장에는 “VIP 회원”들이 있다. 이 사람들은 반드시 자기 좌석에만 앉아야 하며 옆 좌석으로 자리를 옮길 수 없다.

오늘 공연은 입장권이 매진되어 1번 좌석부터 N번 좌석까지 모든 좌석이 다 팔렸다. 
VIP 회원들의 좌석 번호들이 주어졌을 때, 사람들이 좌석에 앉는 서로 다른 방법의 가짓수를 구하는 프로그램을 작성하시오.

예를 들어서, 그림과 같이 좌석이 9개이고, 4번 좌석과 7번 좌석이 VIP석인 경우에 <123-4-56-7-89>는 물론 가능한 배치이다. 
또한 <213-4-65-7-89> 와 <132-4-65-7-98> 도 가능한 배치이다. 
그러나 <312-4-56-7-89> 와 <1235-4-6-7-89> 는 허용되지 않는 배치 방법이다.



입력
첫째 줄에는 좌석의 개수 N이 입력된다. N은 1 이상 40 이하이다. 
둘째 줄에는 고정석의 개수 M이 입력된다. M은 0 이상 N 이하이다. 
다음 M 개의 줄에는 고정석의 번호가 작은 수부터 큰 수의 순서로 한 줄에 하나씩 입력된다.

출력
주어진 조건을 만족하면서 사람들이 좌석에 앉을 수 있는 방법의 가짓수를 출력한다. 방법의 가짓수는 2,000,000, 000을 넘지 않는다(2,000,000,000<2^31-1).

예제 입력 1  복사
9
2
4
7
예제 출력 1  복사
12


PS:
	* 메모이제이션을 통해 N 길이의 좌석이 주어졌을 때 앉을 수 있는 방법의 가짓수를 저장한다.
	* 반복문을 통해 N 길이의 좌석이 주어졌을 때 앉을 수 있는 방법의 가짓수를 계산한다.
	* 위에 주어진 예시에서 보면 <312456789> 의 경우 불가능 하다고 되어있는데 이를 통해 계속 옆으로 타고갈 수 없다는 것을 알 수 있다.
	  그리고 이미 바꿔 앉은 자석에서 다른 사람과 바꿔앉을 수 없다.
	* 이 문제에선 4개의 경우를 생각해볼 수 있다.
		1. 전부다 VIP -> 1개
		2. 전부다 일반 -> N 길이 좌석에서 사람들이 앉을 수 있는 방법의 수
		3. 일반인, VIP 교대로 앉아있음 -> 1개
		4. 나머지 경우들은 그냥 계산 ( VIP1 - VIP2 사이에 있는 좌석의 수가 가질 수 있는 경우의 수를 정답에 곱한다 )
	* N개의 좌석의 경우를 구하려면 N-1번에 N을 붙이고 N-2번에 (N, N-1)번을 붙이면 된다. (그려보면 나옴)
	
점화식:
	DP[N] = DP[N-1] + DP[N-2]
	
		
import java.io.*;
import java.util.*;

public class Main {

    static int[] dp, vip;
    static int N, M;

    static BufferedReader br = null;
    static BufferedWriter bw = null;

    public static void main(String args[]) throws Exception {

        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        N = Integer.parseInt(br.readLine());
        M = Integer.parseInt(br.readLine());

        dp = new int[N + 1];
        vip = new int[M + 1];

        dp[0] = 1; dp[1] = 1; dp[2] = 2; dp[3] = 3;
        vip[0] = vip[M] = 0;

        for(int i = 4 ; i <= N; ++i)
            dp[i] = dp[i-1] + dp[i-2];

        int ans = 1;

        for(int i = 1; i <= M; ++i) {
            vip[i] = Integer.parseInt(br.readLine());
            ans *= dp[vip[i] - vip[i-1] - 1];
        }

        ans *= dp[N-vip[M]];

        bw.write(ans + "\n");
        bw.flush();
    }
}







