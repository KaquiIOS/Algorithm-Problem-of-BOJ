* 그래프 알고리즘


1. DFS






2. BFS






3. Union - Find (Disjoint-Set)

	* 입력된 노드들이 같은 그래프안에 존재하는지 확인하는 알고리즘
	* 가능한 연산은 노드 연결, 노드 부모 찾기, 노드가 같은 그래프에 존재하는지 확인 세가지다.
	
	< 노드 부모 찾기 >
	1. 입력된 노드가 자신과 같은 노드이면 현재 노드는 최종 부모이다.
	2. 입력된 노드가 자신과 같은 값이 아니면 현재 노드는 최종 부모가 아니다.
		-> 1번 상태가 될 때 까지 자신의 부모 노드를 재귀적으로 방문한다.
	

	< 두 노드 연결하기 >
	1. 먼저 노드들의 최종 부모를 재귀함수를 이용하여 탐색한다.
	2. 탐색된 최종 부모 노드가 다른 경우에만 노드 연결을 시도한다.
		* 입력된 두 노드의 부모를 변경하는 것이 아니라 탐색된 최종 부모노드의 부모를 변경하는 것이다.
		-> 최종 부모 노드의 값이 낮은 쪽을 값이 큰 노드의 부모로 설정한다.
		
	< 노드가 같은 그래프에 존재하는지 확인 >
	1. 입력된 노드들의 최종 부모들을 < 노드 부모 찾기 > 를 통해 불러온다.
	2. 불러온 노드들의 최종 부모가 다 동일하면 true 아니면 false 이다.

	< 3. BOJ 4195 번 예제 >  https://www.acmicpc.net/problem/4195
	< 2. BOJ 1976 번 예제 >  https://www.acmicpc.net/problem/1976
	< 1. BOJ 1717 번 예제 >  https://www.acmicpc.net/problem/1717
	
	
4. MST

	* 최소한의 비용으로 모든 노드를 연결하기 위한 알고리즘
	* 각 알고리즘에 따라 노드를 연결하는 방식이 달라짐
	* 간선의 수는 노드의 수 - 1개로 고정. ( N개의 노드를 연결하는데 N-1개의 간선이면 연결 가능)
	* 사이클이 발생 X ( 사이클이 발생하면 노드 수 - 1개로 모든 노드를 연결할 수 없게됨 )
	
	
	- Kruskal
	* 입력된 간선들 중 최소 비용을 가지는 간선들을 우선적으로 선택하는 알고리즘
	* 사이클 발생 유무는 Union-Find 알고리즘을 통해 판단
		- 같은 최상위 조상을 가짐 -> 사이클 발생, 해당 간선 제외
		- 다른 최상위 조상을 가짐 -> 다른 그래프들을 연결
	* 간선 정렬, 사이클 유무 확인, 제외/연결 순서로 실행한다.
	* 간선 정렬대신 우선순위 큐를 이용하여 정렬하면 더 빠른 시간에 문제를 해결할 수 있다.
	
	< 간선 정렬 >
	1. 가장 cost 가 낮은 순서대로 간선을 정렬한다.
	
	< 사이클 유무 확인 >
	1. 입력된 간선의 start, end 지점이 연결되었을 때 사이클이 생기는지 확인
		- 사이클 O -> 제외
		- 사이클 X -> 연결
	
	< 1. BOJ 9372번 예제 > https://www.acmicpc.net/problem/9372
	< 2. BOJ 1197번 예제 > https://www.acmicpc.net/problem/1197
	< 3. BOJ 1922번 예제 > https://www.acmicpc.net/problem/1922
	
	
	
	
	- Prim
	
	
	
	
	- Solin
	
	
	
	
5. Strong Conn
	
	
	
6. Topology Sort

	
7. Dijkstra



8. BellmanFord



9. Floyd - Warshall


